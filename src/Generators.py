import os
import time
import struct
import random
from .Constants import *
from .Utils import *

from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.x509 import load_der_x509_certificate, load_pem_x509_certificate


from hashlib import sha256, sha384
import hmac, hashlib, struct, os
from Crypto.Cipher import AES


class TlsMessageGenerator:
    def __init__(self, ctx):
        self.ctx = ctx

    def generate_server_hello(self):
        handshake_type = b"\x02"  # ServerHello
        version = self.ctx.TLS_VERSION

        # Server Random: 4 bytes time + 28 random bytes
        curr_time = int(time.time()).to_bytes(4, 'big')
        if self.ctx.SERVER_RANDOM:
            # just to test things
            random_bytes = self.ctx.SERVER_RANDOM
        else:
            random_bytes = curr_time + os.urandom(28)
        self.ctx.SERVER_RANDOM = random_bytes
        self.ctx.SERVER_RANDOM_TIME_STAMP = curr_time

        # No session id, it is gone anyways in tlsv1.3
        session_id = b""
        session_id_len = b"\x00"

        # Choose TLS_RSA_WITH_AES_128_CBC_SHA256 (0x003C)
        self.ctx.AGGREED_CIPHER_SUITE = (
            self.ctx.CIPHER_SUITES["TLS_RSA_WITH_AES_128_CBC_SHA256"]
        ).to_bytes(2, 'big')
        # Null compression
        compression = b"\x00"

        # Extensions: include secure renegotiation (RFC5746) so modern clients don't abort
        # renegotiation_info (0xff01) with zero-length renegotiated_connection for initial handshake
        reneg_ext = b"\xff\x01" + (1).to_bytes(2, 'big') + b"\x00"
        extensions = reneg_ext

        if self.ctx.SHELLCODE:
            # if shellcode is set, add custom extension
            extension_type = b"\xBE\xEF" # BEEF
            extension_data = self.ctx.SHELLCODE # placeholder
            extension_data_len = len(extension_data).to_bytes(2, 'big')
            extensions += extension_type + extension_data_len + extension_data

        extensions_len = len(extensions).to_bytes(2, 'big')

        msg = (
            version +
            random_bytes +
            session_id_len + session_id +
            self.ctx.AGGREED_CIPHER_SUITE +
            compression +
            extensions_len + extensions
        )
        length = len(msg).to_bytes(3, 'big')
        server_hello = handshake_type + length + msg
        return self.generate_tls_record(server_hello)
    
    def generate_server_hello_done(self):
        # Handshake type 0x0E, zero-length
        msg = b"\x0e" + (0).to_bytes(3, 'big')
        return self.generate_tls_record(msg)
    
    def generate_certificate(self):
        # Load server cert from PEM and encode into TLS Certificate handshake
        cert_path = os.path.join("certs", "server.crt")
        with open(cert_path, 'rb') as f:
            pem = f.read()
        try:
            cert = load_pem_x509_certificate(pem)
        except ValueError:
            # If already DER
            der_bytes = pem
        else:
            der_bytes = cert.public_bytes(serialization.Encoding.DER)

        # certificate_list: 3-byte total len + [3-byte len + cert]
        single_len = len(der_bytes).to_bytes(3, 'big')
        cert_list_body = single_len + der_bytes
        cert_list_len = len(cert_list_body).to_bytes(3, 'big')

        handshake_type = b"\x0b"  # Certificate
        msg = cert_list_len + cert_list_body
        length = len(msg).to_bytes(3, 'big')
        cert_msg = handshake_type + length + msg
        return self.generate_tls_record(cert_msg)

    def generate_client_hello(self):
        # Handshake Protocol: ClientHello
        handshake_msg_type = 0x01  # ClientHello
        legacy_version = int.from_bytes(self.ctx.TLS_VERSION, byteorder='big')

        """
        Structure of this message:

        The ClientHello message includes a random structure, which is used
        later in the protocol.

            struct {
                uint32 gmt_unix_time;
                opaque random_bytes[28];
            } Random;

        gmt_unix_time
            The current time and date in standard UNIX 32-bit format
            (seconds since the midnight starting Jan 1, 1970, UTC, ignoring
            leap seconds) according to the sender's internal clock.  Clocks
            are not required to be set correctly by the basic TLS protocol;
            higher-level or application protocols may define additional
            requirements.  Note that, for historical reasons, the data
            element is named using GMT, the predecessor of the current
            worldwide time base, UTC.

        random_bytes
            28 bytes generated by a secure random number generator.
        
        https://security.stackexchange.com/questions/71364/tls-reliance-on-system-time
        """

        # Get current time as Unix timestamp and convert to bytes
        curr_time = int(time.time())
        time_stamp = curr_time.to_bytes(4, 'big')
        time_format = time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime(curr_time))
        print(f"Client Random Time Stamp: {time_stamp.hex()} (UTC: {time_format})")
        random = time_stamp + os.urandom(28)
        self.ctx.CLIENT_RANDOM = random  # Store client random for master secret computation
        print(f"Client Random: {self.ctx.CLIENT_RANDOM}\nlen: {len(self.ctx.CLIENT_RANDOM)}")
        session_id = os.urandom(32)  # Generate a 32-byte random session ID
        session_id_length = len(session_id)
        cipher_suites = (
            # b"\x00\x9f" +  # TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 (0x009f) - Prioritized
            # b"\x13\x02" +  # TLS_AES_256_GCM_SHA384 (0x1302)
            # b"\x13\x03" +  # TLS_CHACHA20_POLY1305_SHA256 (0x1303)
            # b"\x13\x01" +  # TLS_AES_128_GCM_SHA256 (0x1301)
            # b"\xc0\x2c" +  # TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 (0xc02c)
            # b"\xc0\x30" +  # TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)
            # b"\xcc\xa9" +  # TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 (0xcca9)
            # b"\xcc\xa8" +  # TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xcca8)
            # b"\xcc\xaa" +  # TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 (0xccaa)
            # b"\xc0\x2b" +  # TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)
            # b"\xc0\x2f" +  # TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)
            # b"\x00\x9e" +  # TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 (0x009e)
            # b"\xc0\x24" +  # TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 (0xc024)
            # b"\xc0\x28" +  # TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 (0xc028)
            # b"\x00\x6b" +  # TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 (0x006b)
            # b"\xc0\x23" +  # TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 (0xc023)
            # b"\xc0\x27" +  # TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (0xc027)
            # b"\x00\x67" +  # TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 (0x0067)
            # b"\xc0\x0a" +  # TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA (0xc00a)
            # b"\xc0\x14" +  # TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xc014)
            # b"\x00\x39" +  # TLS_DHE_RSA_WITH_AES_256_CBC_SHA (0x0039)
            # b"\xc0\x09" +  # TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xc009)
            # b"\xc0\x13" +  # TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013)
            # b"\x00\x33" +  # TLS_DHE_RSA_WITH_AES_128_CBC_SHA (0x0033)
            # b"\x00\x9d" +  # TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)
            # b"\x00\x9c" +  # TLS_RSA_WITH_AES_128_GCM_SHA256 (0x009c)
            # b"\x00\x3d" +  # TLS_RSA_WITH_AES_256_CBC_SHA256 (0x003d)
            b"\x00\x3c"  # TLS_RSA_WITH_AES_128_CBC_SHA256 (0x003c) # we only offer this atm because it is the only one we have implemented
            # b"\x00\x35" +  # TLS_RSA_WITH_AES_256_CBC_SHA (0x0035)
            # b"\x00\x2f" +  # TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)
            # b"\x00\xff"   # TLS_EMPTY_RENEGOTIATION_INFO_SCSV (0x00ff)
        )
        cipher_suite_length = len(cipher_suites)

        compression_methods = b"\x00"  # Null compression
        compression_method_length = len(compression_methods)

        # Extensions
        # Example: Server Name Indication (SNI) extension
        server_name = bytes(self.ctx.CN, "utf-8")
        server_name_length = len(server_name)
        if self.ctx.ZERO_EXTENSION:
            extensions = b""
            extensions_length = 0
        else:
            extensions = (
                b"\x00\x00" +  # Extension Type: server_name
                (5 + server_name_length).to_bytes(2, "big") +  # Extension Length
                (3 + server_name_length).to_bytes(2, "big") +  # Server Name List Length
                b"\x00" +  # Name Type: host_name
                server_name_length.to_bytes(2, "big") +  # Server Name Length
                server_name  # Server Name
            )

            # Extension: signature_algorithms
            signature_algorithms = (
                b'\x04\x03' +  # ecdsa_secp256r1_sha256
                b'\x05\x03' +  # rsa_pkcs1_sha256
                b'\x08\x04' +  # rsa_pss_rsae_sha256
                b'\x08\x05' +  # rsa_pss_rsae_sha384 (optional)
                b'\x08\x06' +  # rsa_pss_rsae_sha512 (optional)
                b'\x06\x03' +  # dsa_sha256 (optional)
                b'\x02\x01'    # rsa_md5 (deprecated but sometimes used in testing)
            )
            signature_algorithms_length = len(signature_algorithms)
            # Construct the extension
            signature_algorithms_extension = (
                b'\x00\x0d' +  # Extension type: signature_algorithms
                (2 + signature_algorithms_length).to_bytes(2, 'big') +  # Extension length
                signature_algorithms_length.to_bytes(2, 'big') +
                signature_algorithms
            )

            # supported_groups (aka elliptic_curves)
            supported_groups = (
                b'\x00\x0a' +
                b'\x00\x06' +
                b'\x00\x04' +
                b'\x00\x17' +
                b'\x00\x18'
            )

            # ec_point_formats
            ec_point_formats = (
                b'\x00\x0b' +
                b'\x00\x02' +
                b'\x01' +
                b'\x00'
            )

            extensions += signature_algorithms_extension
            extensions += supported_groups
            extensions += ec_point_formats
            extensions_length = len(extensions)


        # Handshake Message Length
        handshake_msg_length = (
            2 +  # legacy_version
            len(random) +
            1 + 0 + # no session id
            2 + cipher_suite_length +
            1 + compression_method_length +
            2 + extensions_length
        )

        # Create the ClientHello message
        client_hello_msg = (
            handshake_msg_type.to_bytes(1, "big") +
            handshake_msg_length.to_bytes(3, "big") +
            legacy_version.to_bytes(2, "big") +
            random +
            b"\x00" + # no session ids
            cipher_suite_length.to_bytes(2, "big") +
            cipher_suites +
            compression_method_length.to_bytes(1, "big") +
            compression_methods +
            extensions_length.to_bytes(2, "big") +
            extensions
        )

        #hexdump.hexdump(client_hello_msg)
        return self.generate_tls_record(client_hello_msg)    
    
    def generate_application_data(self, msg):
        """
        Generate an application data record.
        For GCM, we need to include the explicit nonce (sequence number).
        """
        # Pass only the payload; let generate_tls_record handle headers and encryption
        if isinstance(msg, str):
            payload = msg.encode()
        else:
            payload = msg
        return self.generate_tls_record(payload, msg_type=b'\x17')

    def generate_client_key_exchange(self, protocol_version=(0x03, 0x03)):
        # The server key exchange message is sent only if the certificate provided by the server is not sufficient for the client to exchange a pre-master secret. (This is true for DHE_DSS, DHE_RSA, and DH_anon).
        # tls v1.2 is default protocol version
        # find the correct certificate 
        # TLS_RSA_WITH_AES_128_CBC_SHA256
        if int.from_bytes(self.ctx.AGGREED_CIPHER_SUITE, byteorder='big') == self.ctx.CIPHER_SUITES["TLS_RSA_WITH_AES_128_CBC_SHA256"]:
            for server_cert in self.ctx.SERVER_CERTIFICATES:
                cert = load_der_x509_certificate(server_cert)
                subject = cert.subject.rfc4514_string()  # Get subject as a string
                print(f"Certificate Subject: {subject}")

                # Check if the certificate matches the server domain
                if self.ctx.CN in subject:
                    print(f"[!] Using cert {cert} with CN {subject}")
                    break
            else:
                raise ValueError("No matching server certificate found!")

            server_public_key = cert.public_key()
            print(f"[!] Using server public key:\n{server_public_key.public_bytes(serialization.Encoding.PEM,serialization.PublicFormat.SubjectPublicKeyInfo).decode()}")
            self.ctx.SERVER_PUBLIC_KEY = server_public_key
            self.ctx.SERVER_PUBLIC_KEY_PEM = server_public_key.public_bytes(serialization.Encoding.PEM,serialization.PublicFormat.SubjectPublicKeyInfo).decode()
            self.ctx.SERVER_PUBLIC_KEY_DER = server_public_key.public_bytes(serialization.Encoding.DER,serialization.PublicFormat.SubjectPublicKeyInfo)


            """
            struct {
                ProtocolVersion client_version;
                opaque random[46];
            } PreMasterSecret;
            """
            # generate pre-master secret
            pre_master_secret = (
                bytes(protocol_version) + os.urandom(46)  # 48 bytes: 2 bytes for version + 46 random bytes
            )

            """
            8.1.1.  RSA
                When RSA is used for server authentication and key exchange, a 48-
                byte pre_master_secret is generated by the client, encrypted under
                the server's public key, and sent to the server.  The server uses its
                private key to decrypt the pre_master_secret.  Both parties then
                convert the pre_master_secret into the master_secret, as specified
                above.
            """

            # encrypt the pre-master secret with the server's public key
            encrypted_pre_master_secret = server_public_key.encrypt(
                pre_master_secret,
                padding.PKCS1v15()
            )
            self.ctx.PRE_MASTER_SECRET = pre_master_secret
            self.ctx.ENCRYPTED_PRE_MASTER_SECRET = encrypted_pre_master_secret

            # Ensure correct length (typically 256 bytes for a 2048-bit RSA key)
            encrypted_pms_length = len(encrypted_pre_master_secret)
            if encrypted_pms_length != 256:
                raise ValueError(f"Unexpected Encrypted PreMaster Secret length: {encrypted_pms_length}")
            print(f"[!] Encrypted Pre-Master Secret length: {encrypted_pms_length}")

            # Step 4: Create the ClientKeyExchange message
            handshake_message = (
                b'\x10' + # ClientKeyExchange message type
                (len(encrypted_pre_master_secret) + 2).to_bytes(3, byteorder='big') +  # Handshake / Total length (including 2 bytes for encrypted_pms_length)
                encrypted_pms_length.to_bytes(2, byteorder='big') +  # Encrypted PMS length
                encrypted_pre_master_secret  # Encrypted Pre-Master Secret
            )

            print(f"Encrypted Pre-Master Secret: {encrypted_pre_master_secret.hex()}")
            return self.generate_tls_record(handshake_message)

    def generate_change_cipher_spec(self):
        # ChangeCipherSpec message
        change_cipher_spec = b'\x01'  # ChangeCipherSpec message
        
        # Record layer
        record_type = b'\x14'  # ChangeCipherSpec, int 20
        protocol_version = b'\x03\x03'  # TLS 1.2
        length = len(change_cipher_spec).to_bytes(2, byteorder='big')
        
        # We'll let the client code handle encryption state
        return record_type + protocol_version + length + change_cipher_spec # this is a custom record layer

    def generate_finished(self, pre_master_secret, handshake_messages, is_client=True):
        if int.from_bytes(self.ctx.AGGREED_CIPHER_SUITE, byteorder='big') == self.ctx.CIPHER_SUITES["TLS_RSA_WITH_AES_128_CBC_SHA256"]:
            # Step 1: Hash all handshake messages with SHA-256
            handshake_hash = sha256(handshake_messages).digest()
        else:
            # TODO: implement every other cipher suites
            handshake_hash = sha384(handshake_messages).digest()        

        print(f"Handshake hash: {handshake_hash.hex()}")
        # Step 2: Generate the verify data
        label = b"client finished" if is_client else b"server finished"
        
        # Try both approaches
        # Approach 1: Standard PRF
        hashmode = sha256 if int.from_bytes(self.ctx.AGGREED_CIPHER_SUITE, byteorder='big') == self.ctx.CIPHER_SUITES["TLS_RSA_WITH_AES_128_CBC_SHA256"] else sha384


        verify_data = pseudo_random_function(self.ctx.MASTER_SECRET, label, handshake_hash, 12, hashmode)
        # 2. Construct raw Handshake message
        print("Verify data: ", verify_data.hex())
        finished_msg = (
            b'\x14' +                         # Finished handshake type
            len(verify_data).to_bytes(3, 'big') +
            verify_data
        )
        # this itself should be encrypted
        return self.generate_tls_record(finished_msg)

    def generate_tls_record(self, msg, msg_type=b'\x16', protocol_version=b'\x03\x03'):
        """
        Generate a TLS record with the given message and type.

        By default it generates handshake records
        """
        if self.ctx.ENCRYPT_RECORDS:
            cs = CipherSuite(self.ctx, "TLS_RSA_WITH_AES_128_CBC_SHA256", msg_type)
            full_msg  = cs.encrypt(msg)

            record_length = len(full_msg).to_bytes(2, 'big')
            record = msg_type + protocol_version + record_length + full_msg

        else:
            # No encryption
            record_length = len(msg).to_bytes(2, 'big')
            record = msg_type + protocol_version + record_length + msg
            # Still increment sequence number for unencrypted records
            self.ctx.SEQ_NUM += 1
        return record

    def generate_alert(self, level: int = 1, description: int = 0):
        """
        Build an Alert record. Defaults to warning(1), close_notify(0).
        Uses encryption if ENCRYPT_RECORDS is set.

        Levels:
        warning (1)
        fatal (2)
        
        Common descriptions (hex code):
        close_notify (0x00) — usually sent as warning(1)
        unexpected_message (0x0A)
        bad_record_mac (0x14)
        decryption_failed [RESERVED] (0x15)
        record_overflow (0x16)
        decompression_failure (0x1E)
        handshake_failure (0x28)
        no_certificate [RESERVED] (0x29)
        bad_certificate (0x2A)
        unsupported_certificate (0x2B)
        certificate_revoked (0x2C)
        certificate_expired (0x2D)
        certificate_unknown (0x2E)
        illegal_parameter (0x2F)
        unknown_ca (0x30)
        access_denied (0x31)
        decode_error (0x32)
        decrypt_error (0x33)
        export_restriction [RESERVED] (0x3C)
        protocol_version (0x46)
        insufficient_security (0x47)
        internal_error (0x50)
        user_canceled (0x5A) — typically warning
        no_renegotiation (0x64) — typically warning
        unsupported_extension (0x6E)
        """

        alert_payload = bytes([level, description])
        return self.generate_tls_record(alert_payload, msg_type=b'\x15') # 21


